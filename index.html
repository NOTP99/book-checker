<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>도서 확인 프로그램</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- SheetJS (Excel Parser) CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&family=Noto+Sans+KR:wght@100..900&display=swap');
        body {
            font-family: 'Noto Sans KR', 'Inter', sans-serif;
            background-color: #f7f9fb;
        }
        /* Hide the loading screen initially */
        #loading-overlay { display: none; }
        
        /* 1. 입력 모드 강제 전환을 위한 CSS (일부 구형 브라우저에서 유효) */
        #scan-input:focus {
            ime-mode: inactive; /* 한영 자동 전환 시도를 위한 힌트만 유지 */
        }
        /* 사용자에게 클릭 가능함을 시각적으로 알려줌 */
        .toggle-status {
            cursor: pointer;
        }
    </style>
</head>
<body class="min-h-screen p-4 sm:p-6">

    <div class="max-w-4xl mx-auto bg-white shadow-xl rounded-xl p-6 md:p-8">
        <header class="mb-6 border-b pb-4">
            <h1 class="text-3xl font-bold text-gray-800">📚 도서 확인 프로그램</h1>
            <p class="text-gray-500 mt-1">엑셀 파일을 불러온 후, 등록 번호, ISBN, 또는 서명을 통해 재고를 실시간으로 확인하세요.</p>
        </header>

        <!-- 로딩 오버레이 -->
        <div id="loading-overlay" class="fixed inset-0 bg-black bg-opacity-30 flex items-center justify-center z-50">
            <div class="bg-white p-6 rounded-lg shadow-2xl flex items-center">
                <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-indigo-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <span id="loading-text" class="text-gray-700">목록을 처리 중입니다...</span>
            </div>
        </div>

        <!-- 1. 엑셀 파일 업로드 -->
        <section class="mb-6 p-4 border-2 border-dashed border-indigo-300 rounded-lg bg-indigo-50">
            <h2 class="text-xl font-semibold text-indigo-700 mb-2">1. 엑셀 목록 불러오기 (서명, ISBN, 등록 번호 필수)</h2>
            <p class="text-sm text-indigo-600 mb-3">엑셀 파일의 첫 번째 시트를 불러옵니다. **'서명'**, **'ISBN'**, **'등록 번호'** 열이 포함되어 있어야 합니다.</p>
            <input type="file" id="excel-file" accept=".xlsx, .xls, .csv" class="w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-indigo-500 file:text-white hover:file:bg-indigo-600 cursor-pointer">
            <p id="file-status" class="mt-2 text-sm font-medium text-red-500"></p>
        </section>

        <!-- 2. 재고 확인 (스캔/입력) -->
        <section class="mb-8 p-6 bg-gray-100 rounded-lg shadow">
            <h2 class="text-xl font-semibold text-gray-800 mb-4">2. 도서 확인하기 (스캔 또는 입력)</h2>
            <div id="check-area" class="opacity-50 pointer-events-none transition duration-300">
                
                <!-- A. 텍스트 입력/스캔 영역 -->
                <div class="flex flex-col sm:flex-row space-y-3 sm:space-y-0 sm:space-x-3 mb-4">
                    <input type="text" id="scan-input" placeholder="등록 번호, ISBN 또는 책 제목을 입력하세요 (예: HC000797, 97889...)"
                        class="flex-grow p-3 border-2 border-gray-300 rounded-lg focus:outline-none focus:border-indigo-500 text-lg" 
                        disabled
                        inputmode="verbatim" lang="en" spellcheck="false">
                    <button id="check-button" class="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-200 disabled:bg-indigo-300" disabled>
                        재고 확인
                    </button>
                </div>
                
                <div id="check-result" class="mt-4 text-center font-bold text-xl min-h-[30px]"></div>
            </div>
        </section>

        <!-- 3. 도서 목록 및 현황 -->
        <section>
            <h2 class="text-xl font-semibold text-gray-800 mb-4">3. 도서 목록 현황 (<span id="checked-count">0</span> / <span id="total-count">0</span> 권 확인)</h2>
            <div class="flex flex-wrap gap-3 mb-4">
                <button id="export-button" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 disabled:bg-green-300" disabled>
                    ✅ 확인 목록 엑셀로 내보내기 (.xlsx)
                </button>
                <button id="filter-button" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 disabled:bg-gray-300" disabled>
                    🔍 미확인 도서만 보기
                </button>
            </div>
            <div class="overflow-x-auto rounded-lg shadow-md">
                <table id="book-table" class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-indigo-600 text-white">
                        <tr>
                            <!-- 폭 조정: 상태(1/12), 제목(4/12), ISBN(3/12), 등록 번호(3/12), 비고(1/12) -->
                            <th class="px-4 py-3 text-left text-xs font-medium uppercase tracking-wider w-1/12 rounded-tl-lg">상태</th>
                            <th class="px-4 py-3 text-left text-xs font-medium uppercase tracking-wider w-4/12">서명</th>
                            <th class="px-4 py-3 text-left text-xs font-medium uppercase tracking-wider w-3/12">ISBN</th>
                            <th class="px-4 py-3 text-left text-xs font-medium uppercase tracking-wider w-3/12">등록 번호</th>
                            <th class="px-4 py-3 text-left text-xs font-medium uppercase tracking-wider w-1/12 rounded-tr-lg">비고</th>
                        </tr>
                    </thead>
                    <tbody id="book-list-body" class="bg-white divide-y divide-gray-200">
                        <!-- 초기 플레이스홀더 데이터 -->
                        <tr class="bg-gray-50"><td colspan="5" class="p-6 text-center text-gray-500 italic">엑셀 파일을 업로드하면 목록이 여기에 표시됩니다.</td></tr>
                    </tbody>
                </table>
            </div>
        </section>

        <!-- 메시지 모달 (alert() 대체) -->
        <div id="message-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 items-center justify-center z-50">
            <div class="bg-white p-6 rounded-lg shadow-2xl max-w-sm w-full">
                <h3 id="modal-title" class="text-xl font-bold mb-3 text-gray-800"></h3>
                <p id="modal-message" class="text-gray-600 mb-4"></p>
                <div class="flex justify-end">
                    <button id="modal-close-button" class="bg-indigo-500 hover:bg-indigo-600 text-white font-semibold py-2 px-4 rounded-lg transition duration-200">확인</button>
                </div>
            </div>
        </div>

    </div>

    <script>
        // 전역 상태 변수
        let bookList = [];
        let totalBookCount = 0;
        let checkedBookCount = 0;
        let showUncheckedOnly = false; // [기능 1] 목록 필터링 상태

        // HTML 요소 참조
        const excelFileEl = document.getElementById('excel-file');
        const fileStatusEl = document.getElementById('file-status');
        const scanInputEl = document.getElementById('scan-input');
        const checkButtonEl = document.getElementById('check-button');
        const checkResultEl = document.getElementById('check-result');
        const bookListBodyEl = document.getElementById('book-list-body');
        const checkAreaEl = document.getElementById('check-area');
        const totalCountEl = document.getElementById('total-count');
        const checkedCountEl = document.getElementById('checked-count');
        const loadingOverlayEl = document.getElementById('loading-overlay');
        const loadingTextEl = document.getElementById('loading-text');
        const exportButtonEl = document.getElementById('export-button');
        const filterButtonEl = document.getElementById('filter-button'); // [기능 1] 필터 버튼 참조

        // 모달 요소 참조
        const messageModalEl = document.getElementById('message-modal');
        const modalTitleEl = document.getElementById('modal-title');
        const modalMessageEl = document.getElementById('modal-message');
        const modalCloseButtonEl = document.getElementById('modal-close-button');
        
        // **엑셀 원본 헤더**
        let originalExcelHeaders = [];

        // 비고 입력 필드 업데이트 함수 (HTML에서 직접 호출됨)
        function updateRemarks(index, value) {
            const bookIndex = parseInt(index, 10);
            if (bookIndex >= 0 && bookIndex < bookList.length) {
                const book = bookList[bookIndex];
                if (book) {
                    book.Remarks = value.trim();
                }
            }
        }

        // 모달 표시 함수 (alert() 대체)
        function showMessage(title, message) {
            modalTitleEl.textContent = title;
            modalMessageEl.textContent = message;
            messageModalEl.classList.remove('hidden');
            messageModalEl.classList.add('flex');
        }

        modalCloseButtonEl.addEventListener('click', () => {
            messageModalEl.classList.add('hidden');
            messageModalEl.classList.remove('flex');
            scanInputEl.focus(); 
        });

        // UI 상태 업데이트 함수
        function updateUIState(isLoaded) {
            if (isLoaded) {
                checkAreaEl.classList.remove('opacity-50', 'pointer-events-none');
                scanInputEl.disabled = false;
                checkButtonEl.disabled = false;
                exportButtonEl.disabled = false;
                filterButtonEl.disabled = false; // [기능 1] 필터 버튼 활성화
                scanInputEl.focus();
            } else {
                checkAreaEl.classList.add('opacity-50', 'pointer-events-none');
                scanInputEl.disabled = true;
                checkButtonEl.disabled = true;
                exportButtonEl.disabled = true;
                filterButtonEl.disabled = true; // [기능 1] 필터 버튼 비활성화
            }
        }
        
        // 엑셀 파일을 읽어 bookList를 채우는 함수
        function loadExcel(event) {
            loadingTextEl.textContent = '목록을 처리 중입니다...';
            loadingOverlayEl.style.display = 'flex';
            const file = event.target.files[0];
            if (!file) {
                loadingOverlayEl.style.display = 'none';
                return;
            }

            const fileName = file.name;
            const fileExt = fileName.split('.').pop().toLowerCase();
            if (!['xlsx', 'xls', 'csv'].includes(fileExt)) {
                showMessage("파일 형식 오류", "지원하지 않는 파일 형식입니다. .xlsx, .xls, .csv 파일을 사용해주세요.");
                loadingOverlayEl.style.display = 'none';
                return;
            }

            fileStatusEl.textContent = `파일 로드 중: ${fileName}`;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    
                    const sheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[sheetName];
                    
                    const json = XLSX.utils.sheet_to_json(worksheet, { header: 1, raw: true });

                    if (json.length === 0) {
                        showMessage("데이터 오류", "엑셀 파일에 데이터가 없습니다.");
                        fileStatusEl.textContent = "";
                        updateUIState(false);
                        loadingOverlayEl.style.display = 'none';
                        return;
                    }

                    const headers = json[0];
                    const dataRows = json.slice(1);

                    originalExcelHeaders = headers.map(h => String(h || '').trim());
                    
                    const normalizedHeaders = headers.map(h => h ? h.toString().trim().toUpperCase() : '');
                    
                    const regNoIndex = normalizedHeaders.findIndex(h => h.includes('등록') && h.includes('번호')); 
                    const isbnIndex = normalizedHeaders.findIndex(h => h.includes('ISBN'));
                    const titleIndex = normalizedHeaders.findIndex(h => h.includes('서명') || h.includes('제목') || h.includes('TITLE'));
                    
                    const remarksIndex = normalizedHeaders.findIndex(h => h.includes('비고') || h.includes('REMARKS') || h.includes('COMMENT'));

                    if (regNoIndex === -1 || isbnIndex === -1 || titleIndex === -1) {
                        showMessage("필수 열 누락", `엑셀 헤더에서 '서명', 'ISBN', 또는 '등록 번호' 열을 찾을 수 없습니다.`);
                        fileStatusEl.textContent = "";
                        updateUIState(false);
                        loadingOverlayEl.style.display = 'none';
                        return;
                    }

                    bookList = dataRows.map(row => {
                        const title = row[titleIndex] ? String(row[titleIndex]).trim() : '제목 없음';
                        const rawRegNo = row[regNoIndex] ? String(row[regNoIndex]).trim() : '';
                        const rawIsbn = row[isbnIndex] ? String(row[isbnIndex]).replace(/[^0-9X]/gi, '') : '';
                        const rawRemarks = remarksIndex !== -1 && row[remarksIndex] ? String(row[remarksIndex]).trim() : '';

                        let originalData = {};
                        originalExcelHeaders.forEach((header, i) => {
                            originalData[header] = row[i];
                        });

                        return {
                            OriginalData: originalData,
                            RegNo: rawRegNo,
                            ISBN: rawIsbn,
                            Title: title,
                            checked: false,
                            Remarks: rawRemarks
                        };
                    }).filter(book => book.ISBN || book.RegNo);

                    totalBookCount = bookList.length;
                    checkedBookCount = 0;
                    
                    fileStatusEl.textContent = `✅ ${fileName} 파일 로드 완료. 총 ${totalBookCount}권의 도서 목록.`;
                    
                    updateUIState(true);
                    // 파일 로드 시 필터 상태 초기화 및 UI 업데이트
                    showUncheckedOnly = false; 
                    filterButtonEl.textContent = '🔍 미확인 도서만 보기';
                    filterButtonEl.classList.remove('bg-orange-500', 'hover:bg-orange-600');
                    filterButtonEl.classList.add('bg-gray-400', 'hover:bg-gray-500');
                    renderList();

                    loadingOverlayEl.style.display = 'none';

                } catch (error) {
                    console.error("엑셀 파일 처리 중 오류 발생:", error);
                    showMessage("처리 오류", "엑셀 파일을 처리하는 도중 오류가 발생했습니다. 파일 내용을 확인해주세요.");
                    fileStatusEl.textContent = "";
                    updateUIState(false);
                    loadingOverlayEl.style.display = 'none';
                }
            };

            reader.readAsArrayBuffer(file);
        }

        // [기능 1] 미확인 도서만 보기 필터 토글
        function toggleFilter() {
            showUncheckedOnly = !showUncheckedOnly;
            
            if (showUncheckedOnly) {
                filterButtonEl.textContent = '✅ 전체 목록 보기';
                filterButtonEl.classList.remove('bg-gray-400', 'hover:bg-gray-500');
                filterButtonEl.classList.add('bg-orange-500', 'hover:bg-orange-600');
            } else {
                filterButtonEl.textContent = '🔍 미확인 도서만 보기';
                filterButtonEl.classList.remove('bg-orange-500', 'hover:bg-orange-600');
                filterButtonEl.classList.add('bg-gray-400', 'hover:bg-gray-500');
            }

            renderList();
            scanInputEl.focus();
        }

        // [기능 3] 목록에서 직접 상태를 토글하는 함수
        function toggleCheckStatus(index) {
            if (index >= 0 && index < bookList.length) {
                // 현재 상태를 반전
                bookList[index].checked = !bookList[index].checked;
                renderList();
                scanInputEl.focus(); // 상태 변경 후 입력창에 포커스 유지
            }
        }


        // 목록을 HTML 테이블로 렌더링하는 함수
        function renderList() {
            bookListBodyEl.innerHTML = ''; 
            checkedBookCount = bookList.filter(b => b.checked).length;

            totalCountEl.textContent = totalBookCount;
            checkedCountEl.textContent = checkedBookCount;
            
            // --- [기능 1] 필터링 로직 ---
            let displayList = [...bookList];
            if (showUncheckedOnly) {
                displayList = displayList.filter(book => !book.checked);
            }
            // --- 필터링 로직 끝 ---

            if (totalBookCount > 0 && displayList.length === 0) {
                let message = showUncheckedOnly 
                    ? '🎉 필터링된 도서가 없습니다. 모든 도서가 확인 완료되었거나, 목록 필터가 켜져있습니다.'
                    : '엑셀 파일을 업로드하면 목록이 여기에 표시됩니다.';
                
                bookListBodyEl.innerHTML = `<tr class="bg-gray-50"><td colspan="5" class="p-6 text-center text-gray-500 italic">${message}</td></tr>`;
                
                // 필터가 켜져있어도, 전체 목록이 있다면 스캔 기능은 유지
                if (totalBookCount === 0) {
                    updateUIState(false);
                }
                return;
            } else if (totalBookCount === 0) {
                bookListBodyEl.innerHTML = '<tr class="bg-gray-50"><td colspan="5" class="p-6 text-center text-gray-500 italic">엑셀 파일을 업로드하면 목록이 여기에 표시됩니다.</td></tr>';
                updateUIState(false);
                return;
            }
            
            // 확인된 책을 먼저, 확인되지 않은 책을 나중에 표시 (정렬)
            const sortedList = displayList.sort((a, b) => (a.checked === b.checked) ? 0 : a.checked ? -1 : 1);

            sortedList.forEach((book) => {
                const row = document.createElement('tr');
                const bgColor = book.checked ? 'bg-green-50' : (sortedList.indexOf(book) % 2 === 0 ? 'bg-white' : 'bg-gray-50');
                
                // [기능 3] 상태 토글을 위한 아이콘 및 클래스
                const checkIcon = book.checked 
                    ? '<span class="text-green-600 font-bold text-xl select-none">✓</span>' 
                    : '<span class="text-gray-400 select-none">□</span>';
                
                // 원본 bookList 내에서의 인덱스 (Remarks 업데이트와 상태 토글을 위해 필요)
                const originalIndex = bookList.findIndex(b => b === book); 

                const remarksCellContent = book.checked 
                    ? `<span class="text-gray-600 text-sm">${book.Remarks || '-'}</span>`
                    : `<input type="text" data-index="${originalIndex}" value="${book.Remarks}" placeholder="대출, 파손 등 사유" 
                         class="w-full text-sm p-1 border border-gray-300 rounded focus:outline-none focus:border-indigo-400 bg-white"
                         onchange="updateRemarks(this.getAttribute('data-index'), this.value)">`;


                row.className = `${bgColor} hover:bg-indigo-100 transition duration-150`;
                row.innerHTML = `
                    <td class="px-4 py-3 whitespace-nowrap text-center toggle-status cursor-pointer" data-index="${originalIndex}">${checkIcon}</td>
                    <td class="px-4 py-3 font-medium text-gray-900">${book.Title}</td>
                    <td class="px-4 py-3 text-sm text-gray-500">${book.ISBN}</td>
                    <td class="px-4 py-3 text-sm text-gray-500">${book.RegNo}</td>
                    <td class="px-4 py-3 text-sm">${remarksCellContent}</td>
                `;
                bookListBodyEl.appendChild(row);
            });

            // [기능 3] 이벤트 위임으로 상태 토글 리스너 추가
            document.querySelectorAll('.toggle-status').forEach(cell => {
                cell.addEventListener('click', (e) => {
                    const index = e.currentTarget.getAttribute('data-index');
                    toggleCheckStatus(parseInt(index, 10));
                });
            });

            updateUIState(true); 
        }

        /**
         * 등록 번호의 숫자 부분에서 선행 0을 제거하여 영문 접두사와 의미 있는 숫자 부분만 남깁니다.
         */
        function stripLeadingZeros(regNo) {
            if (!regNo) return '';
            
            const match = regNo.match(/^([A-Z]*)([0-9]*)$/);
            if (!match) return regNo; 
            
            const prefix = match[1];
            let numericPart = match[2];

            const strippedNumeric = numericPart.replace(/^0+/, ''); 
            
            const resultNumeric = (strippedNumeric === '' && numericPart.length > 0) ? '0' : strippedNumeric;
            
            return prefix + resultNumeric;
        }

        /**
         * 한글 입력 모드에서 스캔/입력된 값을 QWERTY 키보드 위치를 기반으로 영문으로 변환합니다.
         */
        function convertKoreanToEnglish(text) {
            if (!text) return '';
            
            const jamoMap = {
                'ㅂ': 'q', 'ㅃ': 'Q', 'ㅈ': 'w', 'ㅉ': 'W', 'ㄷ': 'e', 'ㄸ': 'E', 'ㄱ': 'r', 'ㄲ': 'R', 'ㅅ': 't', 'ㅆ': 'T',
                'ㅁ': 'a', 'ㄴ': 's', 'ㅇ': 'd', 'ㄹ': 'f', 'ㅎ': 'g', 'ㅋ': 'z', 'ㅌ': 'x', 'ㅊ': 'c', 'ㅍ': 'v',
                
                'ㅛ': 'y', 'ㅕ': 'u', 'ㅑ': 'i', 'ㅐ': 'o', 'ㅒ': 'O', 'ㅔ': 'p', 'ㅖ': 'P',
                'ㅗ': 'h', 'ㅓ': 'j', 'ㅏ': 'k', 'ㅣ': 'l', 'ㅠ': 'b', 'ㅜ': 'n', 'ㅡ': 'm',
            };

            let convertedText = '';
            for (const char of text) {
                convertedText += jamoMap[char] || char;
            }

            return convertedText;
        }

        // 스캔 입력값을 처리하고 목록에서 책을 찾아 상태를 업데이트하는 함수 (텍스트 기반)
        function searchAndCheck() {
            const rawInput = scanInputEl.value.trim();
            
            if (bookList.length === 0) {
                 checkResultEl.innerHTML = '<span class="text-orange-500">⚠️ 먼저 엑셀 파일을 업로드해주세요.</span>';
                 scanInputEl.focus();
                 return;
            }

            if (rawInput.length < 3) {
                checkResultEl.innerHTML = '<span class="text-red-500">❌ 최소 3글자 이상 입력해주세요.</span>';
                scanInputEl.focus();
                return;
            }
            
            let correctedInput = convertKoreanToEnglish(rawInput);
            const inputUpper = correctedInput.toUpperCase();
            
            let foundBook = findBookInList(inputUpper);

            displayCheckResult(foundBook, rawInput); 

            scanInputEl.value = '';
            scanInputEl.focus();
        }

        // 제목 기반 검색 로직을 분리하여 사용
        function findBookInList(inputString) {
            const inputUpper = inputString.toUpperCase();
            
            let foundBook = null;

            // 1. 등록 번호 (RegNo) 정규화 매칭 시도
            const normalizedInputRegNo = stripLeadingZeros(inputUpper);
            foundBook = bookList.find(book => {
                const normalizedBookRegNo = stripLeadingZeros(book.RegNo.toUpperCase());
                return normalizedBookRegNo === normalizedInputRegNo;
            });

            // 2. ISBN으로 정확히 매칭 시도
            if (!foundBook) {
                const numericInput = inputUpper.replace(/[^0-9X]/gi, '');
                if (numericInput.length >= 10) {
                    foundBook = bookList.find(book => book.ISBN === numericInput);
                }
            }

            // 3. 서명 (Title)으로 부분 매칭 시도
            if (!foundBook) {
                // 이미 확인된 책은 건너뛰고, 확인되지 않은 책 중에서 찾음 (띄어쓰기 무시)
                const inputNoSpace = inputUpper.replace(/\s/g, '');
                foundBook = bookList.find(book => 
                    book.Title.toUpperCase().replace(/\s/g, '').includes(inputNoSpace) && !book.checked
                );
            }
            
            return foundBook;
        }
        
        // 검색 결과를 화면에 표시하고 상태를 업데이트하는 함수
        function displayCheckResult(foundBook, rawInput) {
            if (foundBook) {
                if (foundBook.checked) {
                    // 이미 확인된 경우: 등록 번호만 표시 유지
                    checkResultEl.innerHTML = `<span class="text-orange-500">⚠️ "${foundBook.Title}"은 이미 확인된 책입니다. (등록 번호: ${foundBook.RegNo})</span>`;
                } else {
                    foundBook.checked = true; // 상태 업데이트
                    renderList(); // 목록 다시 그리기
                    // 확인 완료 메시지는 제목만 표시
                    checkResultEl.innerHTML = `<span class="text-green-600">✅ [확인 완료] "${foundBook.Title}"</span>`;
                }
            } else {
                // 찾지 못한 경우: 입력값만 표시 유지
                checkResultEl.innerHTML = `<span class="text-red-500">❌ "${rawInput}" 목록에서 일치하는 책을 찾을 수 없습니다.</span>`;
            }
        }

        // 현재 목록 상태를 엑셀 파일로 내보내는 함수 (SheetJS 사용)
        function exportToExcel() {
            if (bookList.length === 0) {
                showMessage("내보내기 오류", "내보낼 도서 목록이 없습니다. 파일을 먼저 업로드해주세요.");
                return;
            }
            
            // 1. 최종 헤더 구성: 원본 헤더 + ['확인 상태', '비고']
            const finalHeaders = [...originalExcelHeaders, '확인 상태', '비고'];
            
            // 2. 데이터를 헤더 순서에 맞게 배열로 구성합니다.
            const dataForSheet = bookList.map(book => {
                const row = {};

                // 원본 데이터 필드를 먼저 채웁니다.
                originalExcelHeaders.forEach(header => {
                    // 원본 데이터 필드 값을 가져옵니다. 값이 없으면 빈 문자열 처리
                    row[header] = book.OriginalData[header] || '';
                });

                // 맨 끝에 추가된 필드를 채웁니다.
                row['확인 상태'] = book.checked ? '확인 완료 (✓)' : '미확인 (□)';
                row['비고'] = book.Remarks || '';

                return row;
            });
            
            // 3. SheetJS를 사용하여 워크시트 생성 및 내보내기
            const worksheet = XLSX.utils.json_to_sheet(dataForSheet, { header: finalHeaders });
            const workbook = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(workbook, worksheet, "도서재고확인결과");

            const date = new Date().toISOString().slice(0, 10).replace(/-/g, '');
            XLSX.writeFile(workbook, `도서_재고확인_결과_${date}.xlsx`);
        }


        // 이벤트 리스너 등록
        excelFileEl.addEventListener('change', loadExcel);
        checkButtonEl.addEventListener('click', searchAndCheck);
        exportButtonEl.addEventListener('click', exportToExcel);
        filterButtonEl.addEventListener('click', toggleFilter); // [기능 1] 필터 버튼 리스너 추가
        
        scanInputEl.addEventListener('keypress', function(e) {
            // 엔터 키 입력 시 검색 실행
            if (e.key === 'Enter') {
                e.preventDefault(); // 기본 폼 제출 방지
                searchAndCheck();
            }
        });

        // 초기화 시 로드 버튼 상태 업데이트
        document.addEventListener('DOMContentLoaded', () => {
            updateUIState(false);
        });

        // 초기 목록 렌더링 (플레이스홀더)
        renderList();
    </script>
</body>
</html>
